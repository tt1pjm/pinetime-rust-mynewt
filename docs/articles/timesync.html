<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Bluetooth Time Sync and LVGL on PineTime Mynewt</title>

    
    <!-- Begin scripts/articles/*-header.html: Article Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<meta property="og:title" 
    content="Bluetooth Time Sync and LVGL on PineTime Mynewt" 
    data-rh="true">
<meta property="og:description" 
    content="How PineTime syncs the time over Bluetooth LE with Mynewt and NimBLE... And how we create Watch Faces with LVGL" 
    data-rh="true">
<meta property="og:image" 
    content="https://lupyuen.github.io/images/timesync-gatt.jpg">
<meta property="og:type" 
    content="article" data-rh="true">
<!-- End scripts/articles/*-header.html -->
<!-- Begin scripts/rustdoc-header.html: Header for Custom Markdown files processed by rustdoc, like chip8.md -->
<link rel="alternate" type="application/rss+xml" title="RSS Feed for lupyuen" href="/rss.xml" />
<link rel="stylesheet" type="text/css" href="../normalize.css">
<link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle">
<link rel="stylesheet" type="text/css" href="../dark.css">
<link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle">
<link rel="stylesheet" type="text/css" href="../prism.css">
<script src="../storage.js"></script><noscript>
<link rel="stylesheet" href="../noscript.css"></noscript>
<link rel="shortcut icon" href="../favicon.ico">
<style type="text/css">
    #crate-search {
        background-image: url("../down-arrow.svg");
    }
    a {
        color: #77d;
    }
</style>
<!-- End scripts/rustdoc-header.html -->


</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    <div class="theme-picker" style="left: 0"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg"
        width="18" alt="Pick another theme!"></button>
        <div id="theme-choices"></div>
    </div>
    <script src="../theme.js"></script>
    <script src="../prism.js"></script>
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    <h1 class="title">Bluetooth Time Sync and LVGL on PineTime Mynewt</h1>
    <nav id="TOC"><ul>
<li><a href="#discover-gatt-services-and-characteristics">1 Discover GATT Services and Characteristics</a><ul></ul></li>
<li><a href="#read-gatt-characteristic-for-current-time">2 Read GATT Characteristic for Current Time</a><ul></ul></li>
<li><a href="#set-system-time">3 Set System Time</a><ul></ul></li>
<li><a href="#bluetooth-log-for-time-sync">4 Bluetooth Log for Time Sync</a><ul></ul></li>
<li><a href="#get-the-time">5 Get the Time</a><ul></ul></li>
<li><a href="#create-watch-face">6 Create Watch Face</a><ul></ul></li>
<li><a href="#update-watch-face">7 Update Watch Face</a><ul></ul></li>
<li><a href="#porting-lvgl-to-mynewt">8 Porting LVGL to Mynewt</a><ul>
<li><a href="#lvgl-library-for-mynewt">8.1 LVGL Library for Mynewt</a><ul></ul></li>
<li><a href="#lvgl-display-interface-for-pinetime">8.2 LVGL Display Interface for PineTime</a><ul></ul></li>
<li><a href="#st7789-display-driver">8.3 ST7789 Display Driver</a><ul></ul></li></ul></li>
<li><a href="#whats-next">9 What's Next</a><ul></ul></li></ul></nav><p>If you have a <a href="https://wiki.pine64.org/index.php/PineTime">PineTime Smart Watch</a> and an Android phone, try this...</p>
<ol>
<li>
<p>Install the <a href="https://www.nordicsemi.com/Software-and-tools/Development-Tools/nRF-Connect-for-mobile"><strong>nRF Connect</strong></a> mobile app on your Android phone. Launch the app.</p>
</li>
<li>
<p>Tap on <code>Menu</code> → <code>Configure GATT Server</code> → <code>Add Service</code></p>
</li>
<li>
<p>Set <code>Server Configuration</code> to <code>Current Time Service</code>. Tap <code>OK</code></p>
</li>
<li>
<p>In the app, browse for Bluetooth devices and connect to PineTime</p>
</li>
</ol>
<p>The current date and time appears on PineTime!</p>
<p><em>What is this magic that syncs the date the time from your phone to PineTime?</em></p>
<p>The syncing magic is called <strong>Bluetooth LE Current Time Service</strong>...</p>
<p><img src="https://lupyuen.github.io/images/timesync-gatt.jpg" alt="Bluetooth Time Sync" /></p>
<ol>
<li>
<p>Our phone connects to PineTime over Bluetooth LE</p>
</li>
<li>
<p>PineTime detects the incoming connection. </p>
<p>PineTime transmits a request to discover all <a href="https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt">GATT Services and Characteristics</a> on our phone.</p>
<p>(Like a &quot;reverse snoop&quot;)</p>
</li>
<li>
<p>PineTime discovers that our phone supports the Current Time Service. </p>
<p>PineTime transmits a request to read the current time. </p>
<p>The nRF Connect app on our phone responds with the current time.</p>
</li>
</ol>
<p><em>Is it really necessary to discover ALL GATT Services and Characteristics?</em></p>
<p>Not really... It's actually more efficient for PineTime to connect directly to the Current Time Service without discovering all services.</p>
<p>But for now we'll discover all services as an educational exercise... Also to allow for future extension in case we need to support more services.</p>
<p>Let's learn to discover GATT Services and Characteristics in the <a href="https://github.com/lupyuen/pinetime-rust-mynewt"><code>pinetime-rust-mynewt</code></a> firmware for PineTime...</p>
<h1 id="discover-gatt-services-and-characteristics" class="section-header"><a href="#discover-gatt-services-and-characteristics">1 Discover GATT Services and Characteristics</a></h1>
<p>First step in our Time Sync magic... Detect incoming Bluetooth LE connections.</p>
<p>We're using the open-source <a href="https://github.com/apache/mynewt-nimble">NimBLE Bluetooth LE Stack</a>, which exposes a hook for us to detect incoming connections: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L368-L416"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">//  The NimBLE stack executes this callback function when a GAP Event occurs
static int bleprph_gap_event(struct ble_gap_event *event, void *arg) {
    //  Check the GAP Event
    switch (event-&gt;type) {

        //  When a BLE connection is established...
        case BLE_GAP_EVENT_CONNECT:

            //  Remember the BLE Peer
            blepeer_add(
                event-&gt;connect.conn_handle  //  BLE Connection
            );

            //  Discover all GATT Sevices and Characteristics in the BLE Peer
            blepeer_disc_all(
                event-&gt;connect.conn_handle,  //  BLE Connection
                blecent_on_disc_complete,    //  Callback function that will be called when discovery is complete
                NULL                         //  No argument for callback
            );
</code></pre>
<p>When we see an incoming Bluetooth LE connection, we react by remembering the peer-to-peer connection with <code>blepeer_add</code>. </p>
<p>Then we discover all GATT Services and Characteristics of our peer (mobile phone) by calling <code>blepeer_disc_all</code>.</p>
<p>Here's the callback function that's called when the GATT Services and Characteristics have been discovered: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L88-L107"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Called when GATT Service Discovery of the BLE Peer has completed
static void blecent_on_disc_complete(const struct blepeer *peer, int status, void *arg) {
    //  Omitted: Check that discovery status is successful

    //  GATT Service Discovery has completed successfully.
    //  Now we have a complete list of services, characteristics 
    //  and descriptors that the peer supports.

    //  Read the GATT Characteristics from the peer
    blecent_read(peer);
}
</code></pre>
<p>Now we can call <code>blecent_read</code> to read the Current Time Characteristic exposed to PineTime by our phone. We'll learn how in the next section.</p>
<p><em>What are <code>blepeer_add</code> and <code>blepeer_disc_all</code>?</em></p>
<p>They are <strong>Bluetooth LE Peer Functions</strong> provided by NimBLE to maintain peer-to-peer Bluetooth LE connections and to remember the discovered GATT Services and Characteristics.</p>
<p>See <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_peer.h"><code>apps/my_sensor_app/src/ble_peer.h</code></a> and <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_peer.c"><code>ble_peer.c</code></a> </p>
<h1 id="read-gatt-characteristic-for-current-time" class="section-header"><a href="#read-gatt-characteristic-for-current-time">2 Read GATT Characteristic for Current Time</a></h1>
<p>Our Time Sync story so far...</p>
<ol>
<li>
<p>PineTime has detected an incoming Bluetooth LE connection from our mobile phone</p>
</li>
<li>
<p>PineTime reacts by discovering all GATT Services and Characteristics exposed by our phone (through the nRF Connect mobile app)</p>
</li>
<li>
<p>PineTime is now ready to read the Current Time Characteristic exposed by our phone</p>
</li>
</ol>
<p>Here's how we read the Current Time Characteristic with NimBLE: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L109-L139"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Read the GATT Characteristic for Current Time from the BLE Peer
static void blecent_read(const struct blepeer *peer) {
    //  Find the GATT Characteristic for Current Time Service from the discovered GATT Characteristics
    const struct blepeer_chr *chr = blepeer_chr_find_uuid(
        peer,
        BLE_UUID16_DECLARE( BLE_GATT_SVC_CTS ),      //  GATT Service for Current Time Service
        BLE_UUID16_DECLARE( BLE_GATT_CHR_CUR_TIME )  //  GATT Characteristic for Current Time Service
    );

    //  Omitted: Check that the Current Time Characteristic exists

    //  Read the Current Time Characteristic
    ble_gattc_read(
        peer-&gt;conn_handle,      //  BLE Connection
        chr-&gt;chr.val_handle,    //  GATT Characteristic
        blecent_on_read,        //  Callback function that will be called when reading is complete
        NULL                    //  No argument for callback
    );
}
</code></pre>
<p><code>ble_gattc_read</code> is the function provided by NimBLE to transmit a Bluetooth LE request to read a GATT Characteristic (the Current Time Characteristic).</p>
<p>The Current Time Service and Current Time Characteristic are defined in the <a href="https://www.bluetooth.com/specifications/gatt/services/">Bluetooth Specifications</a>...</p>
<pre><code class="language-c">#define BLE_GATT_SVC_CTS        (0x1805)  //  GATT Service for Current Time Service
#define BLE_GATT_CHR_CUR_TIME   (0x2A2B)  //  GATT Characteristic for Current Time
</code></pre>
<p>The <a href="https://www.bluetooth.com/wp-content/uploads/Sitecore-Media-Library/Gatt/Xml/Services/org.bluetooth.service.current_time.xml">Current Time Characteristic</a> returns the current date and time in this 10-byte format: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L75-L86"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Data Format for Current Time Service. Based on https://github.com/sdalu/mynewt-nimble/blob/495ff291a15306787859a2fe8f2cc8765b546e02/nimble/host/services/cts/src/ble_svc_cts.c
struct ble_current_time {
    uint16_t year;
    uint8_t  month;
    uint8_t  day;
    uint8_t  hours;
    uint8_t  minutes;
    uint8_t  seconds;
    uint8_t  day_of_week;  //  From 1 (Monday) to 7 (Sunday)
    uint8_t  fraction256;
    uint8_t  adjust_reason;
} __attribute__((__packed__));
</code></pre>
<p>So when our phone returns these 10 bytes to PineTime as the current date/time...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">e4</span> <span class="number">07</span> <span class="number">0a</span> <span class="number">04</span> <span class="number">0e</span> <span class="number">05</span> <span class="number">29</span> <span class="number">07</span> <span class="number">87</span> <span class="number">00</span> </pre></div>
<p>PineTime shall decode the 10 bytes as...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04</span> <span class="number">14</span>:<span class="number">05</span>:<span class="number">41.527343</span> <span class="ident">Sunday</span></pre></div>
<p>We'll see in a while how PineTime decodes the 10 bytes and sets the Mynewt system time.</p>
<h1 id="set-system-time" class="section-header"><a href="#set-system-time">3 Set System Time</a></h1>
<p>One fine Sunday afternoon in sunny Singapore, the 4th of October 2020, at 2:05 PM (and 41.527343 seconds), PineTime received these 10 encoded bytes...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="ident">e4</span> <span class="number">07</span> <span class="number">0a</span> <span class="number">04</span> <span class="number">0e</span> <span class="number">05</span> <span class="number">29</span> <span class="number">07</span> <span class="number">87</span> <span class="number">00</span> </pre></div>
<p>That's the Encoded Current Time, in Bluetooth LE format, returned by our phone (with nRF Connect) to PineTime. The NimBLE Bluetooth LE Stack passes these 10 bytes to our firmware in the <strong>Mbuf Format.</strong></p>
<p><em>What's an Mbuf?</em></p>
<p>An <a href="https://mynewt.apache.org/latest/os/core_os/mbuf/mbuf.html">Mbuf (Memory Buffer)</a> is a linked list of fixed-size blocks thats uses RAM efficiently for networking tasks, like Bluetooth LE.</p>
<p>To work with the data inside the Mbuf linked list, we need to &quot;flatten&quot; the Mbuf (like <code>om</code>) into an array or struct (like <code>current_time</code>)...</p>
<pre><code class="language-c">//  Get the Mbuf size
uint16_t om_len = OS_MBUF_PKTLEN(om);

//  Allocate storage for the BLE Current Time
struct ble_current_time current_time;

//  Copy the data from the Mbuf to the BLE Current Time
ble_hs_mbuf_to_flat(  //  Flatten and copy the Mbuf...
    om,               //  From om...
    &amp;current_time,    //  To current_time...
    om_len,           //  For om_len bytes
    NULL
);
</code></pre>
<p>Here's how we use the Mbuf data to decode the Current Time: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L141-L235"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<pre><code class="language-c">/// Called when Current Time GATT Characteristic has been read
static int blecent_on_read(uint16_t conn_handle, const struct ble_gatt_error *error, struct ble_gatt_attr *attr, void *arg) {
    //  Set the system time from the received time in Mbuf format
    set_system_time(attr-&gt;om);
    return 0;
}

/// Set system time given the BLE Current Time in Mbuf format. Based on https://github.com/sdalu/mynewt-nimble/blob/495ff291a15306787859a2fe8f2cc8765b546e02/nimble/host/services/cts/src/ble_svc_cts.c
static int set_system_time(const struct os_mbuf *om) {
    //  Get the Mbuf size
    uint16_t om_len = OS_MBUF_PKTLEN(om);

    //  Allocate storage for the BLE Current Time
    struct ble_current_time current_time;

    //  Copy the data from the Mbuf to the BLE Current Time
    ble_hs_mbuf_to_flat(  //  Flatten and copy the Mbuf...
        om,               //  From om...
		&amp;current_time,    //  To current_time...
        om_len,           //  For om_len bytes
        NULL
    );

    //  Convert BLE Current Time to clocktime format
    struct clocktime ct;
    ct.year = le16toh(current_time.year);
    ct.mon  = current_time.month;
    ct.day  = current_time.day;
    ct.hour = current_time.hours;
    ct.min  = current_time.minutes;
    ct.sec  = current_time.seconds;
    ct.usec = (current_time.fraction256 * 1000000) / 256;
</code></pre>
<p>We have just populated a <code>clocktime</code> struct <code>ct</code> with the decoded date and time values.</p>
<p>Now we fetch the default timezone <code>tz</code> from Mynewt (because it's needed later for setting the time)...</p>
<pre><code class="language-c">    //  Get the timezone, which will used for clocktime conversion
    struct os_timeval tv0;
    struct os_timezone tz;
    os_gettimeofday(&amp;tv0, &amp;tz);
</code></pre>
<p>Mynewt only accepts system time in the <code>timeval</code> format, so we convert it here (passing the timezone)...</p>
<pre><code class="language-c">    //  Convert clocktime format to timeval format, passing the timezone
    struct os_timeval tv;    
    clocktime_to_timeval(&amp;ct, &amp;tz, &amp;tv);
</code></pre>
<p>Finally we call the Mynewt Function <code>os_settimeofday</code> to set the system time.</p>
<pre><code class="language-c">    //  Set the system time in timeval format
    os_settimeofday(&amp;tv, NULL);
</code></pre>
<p>And that's how we sync the time from our mobile phone to PineTime!</p>
<h1 id="bluetooth-log-for-time-sync" class="section-header"><a href="#bluetooth-log-for-time-sync">4 Bluetooth Log for Time Sync</a></h1>
<p>When we perform Time Sync over Bluetooth LE, we'll see these debugging messages emitted by PineTime: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/ble_main.c#L246-L259"><code>apps/my_sensor_app/src/ble_main.c</code></a></p>
<table><thead><tr><th align="left">Debug Message</th><th align="left">Remark</th></tr></thead><tbody>
<tr><td align="left"><code>Starting BLE...</code></td><td align="left">Start the NimBLE Bluetooth LE Stack</td></tr>
<tr><td align="left"><code>BLE started</code></td><td align="left"></td></tr>
<tr><td align="left"><code>Render LVGL display...</code><br><code>Flush display: </code><br><code>left=63, top=27, right=196, bottom=42...</code></td><td align="left">Render the initial watch face</td></tr>
<tr><td align="left"><code>connection established</code></td><td align="left">Mobile phone connects to PineTime</td></tr>
<tr><td align="left"><code>connection updated </code></td><td align="left"></td></tr>
<tr><td align="left"><code>Service discovery complete; </code><br><code>status=0 conn_handle=1</code></td><td align="left">PineTime discovers the Current Time Service</td></tr>
<tr><td align="left"><code>Read complete; </code><br><code>status=0 conn_handle=1 attr_handle=67</code><br><code>value=e4 07 0a 04 0e 05 29 07 87 00 </code></td><td align="left">PineTime reads and receives the <br> 10-byte current time</td></tr>
<tr><td align="left"><code>Current Time: </code><br><code>2020-10-04T14:05:41.527343+00:00</code></td><td align="left">PineTime decodes the current time</td></tr>
<tr><td align="left">...</td><td align="left"></td></tr>
<tr><td align="left"><code>Render LVGL display...</code><br><code>Flush display: </code><br><code>left=60, top=27, right=183, bottom=42...</code></td><td align="left">Render the updated watch face</td></tr>
<tr><td align="left">...</td><td align="left"></td></tr>
<tr><td align="left"><code>Render LVGL display...</code><br><code>Flush display: </code><br><code>left=59, top=27, right=181, bottom=42...</code></td><td align="left">Render the updates every minute</td></tr>
</tbody></table>
<h1 id="get-the-time" class="section-header"><a href="#get-the-time">5 Get the Time</a></h1>
<p>Here's how we fetch the Mynewt system time in C for building Watch Faces: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/watch_face.c#L65-L82"><code>my_sensor_app/src/watch_face.c</code></a></p>
<pre><code class="language-c">//  Get the system time in timeval format
struct os_timeval tv;
struct os_timezone tz;
int rc = os_gettimeofday(&amp;tv, &amp;tz);
if (rc != 0) { console_printf(&quot;Can't get time: %d\n&quot;, rc); return 2; }
</code></pre>
<p>This produces a <a href="http://mynewt.apache.org/v1_7_0/os/core_os/time/os_time.html"><code>timeval</code> struct</a> in <code>tv</code> that indicates the number of microseconds elapsed since Jan 1 1970.</p>
<p>Which isn't really meaningful for building Watch Faces. Let's convert <code>timeval</code> to a <a href="https://github.com/apache/mynewt-core/blob/master/time/datetime/include/datetime/datetime.h#L31-L40"><code>clocktime</code> struct</a> format...</p>
<pre><code class="language-c">//  Convert the time from timeval format to clocktime format
struct clocktime ct;
rc = timeval_to_clocktime(&amp;tv, &amp;tz, &amp;ct);
if (rc != 0) { console_printf(&quot;Can't convert time: %d\n&quot;, rc); return 3; }
</code></pre>
<p>This produces <code>ct</code>, a <a href="https://github.com/apache/mynewt-core/blob/master/time/datetime/include/datetime/datetime.h#L31-L40"><code>clocktime</code> struct</a> that contains the date and time components: day, month, year, hours, minutes, seconds and day of week.</p>
<p>Perfect for building a Watch Face!</p>
<p>If we need the current date and time in printable <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format...</p>
<pre><code class="language-c">//  Format the clocktime time as 2020-10-04T13:20:26.839843+00:00
char buf[50];
rc = datetime_format(&amp;tv, &amp;tz, buf, sizeof(buf));
if (rc != 0) { console_printf(&quot;Can't format time: %d\n&quot;, rc); return 4; }
</code></pre>
<p>This produces the currrent date and time in <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format like...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04T13</span>:<span class="number">20</span>:<span class="number">26.839843</span><span class="op">+</span><span class="number">00</span>:<span class="number">00</span></pre></div>
<p>For our simple Watch Face in C, we'll truncate the time up to the minute...</p>
<pre><code class="language-c">//  Truncate after minute: 2020-10-04T13:20
buf[16] = 0;
</code></pre>
<p>Which looks like this...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04T13</span>:<span class="number">20</span></pre></div>
<p><img src="https://lupyuen.github.io/images/timesync-c-watchface.png" alt="Watch Face in C" /></p>
<h1 id="create-watch-face" class="section-header"><a href="#create-watch-face">6 Create Watch Face</a></h1>
<p>Now that we can sync the time and fetch the current time, let's create a simple watch face in C!</p>
<p>Our Watch Face shall have only one button, laid out on PineTime's 240 x 240 display like this...</p>
<p><img src="https://lupyuen.github.io/images/timesync-coords.jpg" alt="Watch Face Coordinates" /></p>
<p>Here's how we create the button: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/watch_face.c#L29-L57"><code>my_sensor_app/src/watch_face.c</code></a></p>
<pre><code class="language-c">static lv_obj_t *btn;    //  Button
static lv_obj_t *label;  //  Label

/// Render a watch face. Called by main() in rust/app/src/lib.rs
int create_watch_face(void) {
    btn = lv_btn_create(lv_scr_act(), NULL);     //  Add a button the current screen
    lv_obj_set_pos(btn, 10, 10);                 //  Set its position: X=10, Y=10
    lv_obj_set_size(btn, 220, 50);               //  Set its size: Width=220, Height=50
</code></pre>
<p>To display the current date and time on the button, we'll create a label for the button like so...</p>
<pre><code class="language-c">    label = lv_label_create(btn, NULL);          //  Add a label to the button
    lv_label_set_text(label, &quot;Time Sync&quot;);       //  Set the label text
</code></pre>
<p>We're using the <a href="https://docs.lvgl.io/latest/en/html/widgets/btn.html"><strong>Button Widget</strong></a> and <a href="https://docs.lvgl.io/latest/en/html/widgets/label.html"><strong>Label Widget</strong></a> provided by the <a href="https://docs.lvgl.io/latest/en/html/index.html"><strong>LVGL Library (Version 7)</strong></a>, which we have ported to Mynewt on PineTime as <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt"><strong><code>pinetime_lvgl_mynewt</code></strong></a></p>
<p>The Watch Face shall be updated every minute. To do that in Mynewt, we create a <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html"><strong>Callout Timer</strong></a> by calling <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html"><strong><code>os_callout_init</code></strong></a>...</p>
<pre><code class="language-c">    static struct os_callout watch_face_callout;  //  Timer that is triggered every minute
    ...
    //  Set a timer to update the watch face every minute
    os_callout_init(
        &amp;watch_face_callout,   //  Timer for the watch face
        os_eventq_dflt_get(),  //  Use default event queue
        watch_face_callback,   //  Callback function for the timer
        NULL                   //  No argument for the callback function
    );
</code></pre>
<p>To trigger the timer in 60 seconds, we call <a href="https://mynewt.apache.org/latest/os/core_os/callout/callout.html#c.os_callout_reset"><strong><code>os_callout_reset</code></strong></a>...</p>
<pre><code class="language-c">    //  Trigger the timer in 60 seconds
    os_callout_reset(
        &amp;watch_face_callout,   //  Timer for the watch face
        OS_TICKS_PER_SEC * 60  //  Trigger timer in 60 seconds
    );
    return 0;
}
</code></pre>
<p>We have just defined the function <strong><code>create_watch_face</code></strong> that creates our Watch Face and triggers the Callout Timer...</p>
<p><img src="https://lupyuen.github.io/images/timesync-c.jpg" alt="Watch Face Functions" /></p>
<p>Next we shall define two more functions...</p>
<ol>
<li>
<p><strong><code>watch_face_callback</code></strong>: Callback Function that is triggered by the Callout Timer every minute</p>
</li>
<li>
<p><strong><code>update_watch_face</code></strong>: Function that updates the date and time on the PineTime display</p>
</li>
</ol>
<h1 id="update-watch-face" class="section-header"><a href="#update-watch-face">7 Update Watch Face</a></h1>
<p>Let's look at <code>update_watch_face</code>, our function that updates the date and time on the PineTime display: <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/watch_face.c#L59-L87"><code>my_sensor_app/src/watch_face.c</code></a></p>
<p><img src="https://lupyuen.github.io/images/timesync-c2.jpg" alt="Watch Face Function: update_watch_face" /></p>
<pre><code class="language-c">/// Update the watch face
int update_watch_face(void) {
    //  If button or label not created, quit
    if (btn == NULL || label == NULL) { return 1; }

    //  Get the system time
    struct os_timeval tv;
    struct os_timezone tz;
    int rc = os_gettimeofday(&amp;tv, &amp;tz);
    if (rc != 0) { console_printf(&quot;Can't get time: %d\n&quot;, rc); return 2; }

    //  Convert the time
    struct clocktime ct;
    rc = timeval_to_clocktime(&amp;tv, &amp;tz, &amp;ct);
    if (rc != 0) { console_printf(&quot;Can't convert time: %d\n&quot;, rc); return 3; }

    //  Format the time as 2020-10-04T13:20:26.839843+00:00
    char buf[50];
    rc = datetime_format(&amp;tv, &amp;tz, buf, sizeof(buf));
    if (rc != 0) { console_printf(&quot;Can't format time: %d\n&quot;, rc); return 4; }

    //  Truncate after minute: 2020-10-04T13:20
    buf[16] = 0;
</code></pre>
<p>Here's the code for fetching the current date and time, which we have seen in the previous section.</p>
<p>After fetching the current date and time, <code>update_watch_face</code> does this...</p>
<pre><code class="language-c">    //  Set the label text
    lv_label_set_text(label, buf);
    return 0;
}
</code></pre>
<p><code>buf</code> contains the current date and time in the format...</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="number">2020</span><span class="op">-</span><span class="number">10</span><span class="op">-</span><span class="number">04T13</span>:<span class="number">20</span></pre></div>
<p>When we call the LVGL Function <code>lv_label_set_text</code>, our Button Label will be set to the current date and time.</p>
<p>Thus to make a functioning Watch Face, we need to call <code>update_watch_face</code> every minute.</p>
<p>And that's handled by <code>watch_face_callback</code> in <a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/apps/my_sensor_app/src/watch_face.c#L89-L104"><code>my_sensor_app/src/watch_face.c</code></a></p>
<p><img src="https://lupyuen.github.io/images/timesync-c3.jpg" alt="Watch Face Function: watch_face_callback" /></p>
<pre><code class="language-c">/// Timer callback that is called every minute
static void watch_face_callback(struct os_event *ev) {
    assert(ev != NULL);

    //  Update the watch face
    update_watch_face();
</code></pre>
<p>Remember that <code>watch_face_callback</code> is first triggered by the Callout Timer in <code>create_watch_face</code>.</p>
<p>Here we call <code>update_watch_face</code> to set our Button Label to the current date and time (as we have seen above).</p>
<p>Next we render the LVGL Button and Label to PineTime's display...</p>
<pre><code class="language-c">    //  Render the watch face
    pinetime_lvgl_mynewt_render();
</code></pre>
<p>Finally we set our Callout Timer to trigger <code>watch_face_callback</code> again in 60 seconds...</p>
<pre><code class="language-c">    //  Set the watch face timer
    os_callout_reset(
        &amp;watch_face_callout,   //  Timer for the watch face
        OS_TICKS_PER_SEC * 60  //  Trigger timer in 60 seconds
    );
}
</code></pre>
<p>That's how we create a simple watch face in C!</p>
<h1 id="porting-lvgl-to-mynewt" class="section-header"><a href="#porting-lvgl-to-mynewt">8 Porting LVGL to Mynewt</a></h1>
<p>The above Watch Face was created with <a href="https://docs.lvgl.io/latest/en/html/index.html">LVGL Library (Version 7)</a> that has been ported to PineTime Mynewt as <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt"><code>pinetime_lvgl_mynewt</code></a></p>
<p>Let's learn what's inside <code>pinetime_lvgl_mynewt</code>...</p>
<h2 id="lvgl-library-for-mynewt" class="section-header"><a href="#lvgl-library-for-mynewt">8.1 LVGL Library for Mynewt</a></h2>
<p>During the build of <code>pinetime-rust-mynewt</code> firmware, the <code>pinetime_lvgl_mynewt</code> library is checked out at <code>libs/pinetime_lvgl_mynewt</code>.</p>
<p>The library exposes an initialisation function <code>pinetime_lvgl_mynewt_init</code> that's defined in <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/src/pinetime/lvgl.c"><code>src/pinetime/lvgl.c</code></a>...</p>
<pre><code class="language-c">/// Init the LVGL library. Called by sysinit() during startup, defined in pkg.yml.
void pinetime_lvgl_mynewt_init(void) {    
    console_printf(&quot;Init LVGL...\n&quot;); console_flush();
    assert(pinetime_lvgl_mynewt_started == false);

    //  Init the display controller
    int rc = pinetime_lvgl_mynewt_init_display(); assert(rc == 0);

    //  Init the LVGL display
    lv_init();
    lv_port_disp_init();
    pinetime_lvgl_mynewt_started = true;
}
</code></pre>
<p><code>pinetime_lvgl_mynewt_init</code> is automatically called by Mynewt during startup as specified in <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/pkg.yml"><code>pkg.yml</code></a>...</p>
<pre><code class="language-yaml"># Initialisation functions to be called by sysinit() during startup.
# Mynewt consolidates the initialisation functions into sysinit()
# and calls them according to the Stage number, highest number first.
# Stage 500 is used by Sensor Creator so we use Stage 600 onwards.
# Generated sysinit() for Bootloader: bin/targets/nrf52_boot/generated/src/nrf52_boot-sysinit-app.c

pkg.init:
    # pinetime_lvgl_mynewt should be initialised last, when SPI and Semihosting Console are up
    pinetime_lvgl_mynewt_init: 900  # Call pinetime_lvgl_mynewt_init() to initialise LVGL
</code></pre>
<p>Our <code>pinetime_lvgl_mynewt</code> library also exposes a rendering function <code>pinetime_lvgl_mynewt_render</code>, which we call every minute to update the Watch Face...</p>
<pre><code class="language-c">/// Render the LVGL display
int pinetime_lvgl_mynewt_render(void) {
    console_printf(&quot;Render LVGL display...\n&quot;); console_flush();
    //  Must tick at least 100 milliseconds to force LVGL to update display
    lv_tick_inc(100);
    //  LVGL will flush our display driver
    lv_task_handler();
    return 0;
}
</code></pre>
<p><code>lv_init</code>, <code>lv_port_disp_init</code>, <code>lv_tick_inc</code> and <code>lv_task_handler</code> are described in the <a href="https://docs.lvgl.io/latest/en/html/porting/project.html">LVGL porting docs</a>.</p>
<h2 id="lvgl-display-interface-for-pinetime" class="section-header"><a href="#lvgl-display-interface-for-pinetime">8.2 LVGL Display Interface for PineTime</a></h2>
<p>To allow LVGL to render to PineTime's display, we expose this display interface function: <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/src/pinetime/lv_port_disp.c"><code>src/pinetime/lv_port_disp.c</code></a></p>
<pre><code class="language-c">///  Write Pixels (RAMWR) Command
#define RAMWR 0x2C

/// Flush the content of the internal buffer the specific area on the display
static void disp_flush(lv_disp_drv_t * disp_drv, const lv_area_t * area, lv_color_t * color_p) {
    //  Validate parameters
    assert(area-&gt;x2 &gt;= area-&gt;x1);
    assert(area-&gt;y2 &gt;= area-&gt;y1);

    //  Set the ST7789 display window
    pinetime_lvgl_mynewt_set_window(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2);

    //  Write Pixels (RAMWR)
    int len = 
        ((area-&gt;x2 - area-&gt;x1) + 1) *  //  Width
        ((area-&gt;y2 - area-&gt;y1) + 1) *  //  Height
        2;                             //  2 bytes per pixel
    pinetime_lvgl_mynewt_write_command(RAMWR, NULL, 0);
    pinetime_lvgl_mynewt_write_data((const uint8_t *) color_p, len);

    //  IMPORTANT!!! Inform the graphics library that you are ready with the flushing
    lv_disp_flush_ready(disp_drv);
}
</code></pre>
<p><a href="https://docs.lvgl.io/latest/en/html/porting/display.html">According to the LVGL porting docs,</a> LVGL's <code>lv_task_handler</code> calls <code>disp_flush</code> whenever it needs to flush the contents of LVGL's internal rendering buffer to PineTime's display.</p>
<p>(The rendering buffer is a partial framebuffer... Because PineTime's 64 KB RAM doesn't have sufficient space for a complete 115 KB framebuffer at 240x240 resolution, 16-bit RGB565 colour)</p>
<p><code>disp_flush</code> calls three <code>pinetime_lvgl_mynewt</code> functions from our display driver, which is described in the next section...</p>
<h2 id="st7789-display-driver" class="section-header"><a href="#st7789-display-driver">8.3 ST7789 Display Driver</a></h2>
<p>The <code>pinetime_lvgl_mynewt</code> library includes a simple display driver for PineTime's <a href="https://wiki.pine64.org/images/5/54/ST7789V_v1.6.pdf">ST7789 Display Controller</a>.</p>
<p>We render pixels to the display as a <strong>Rectangular Window</strong> bounded by the coordinares <code>(left, top)</code> and <code>(right, bottom)</code> like so...</p>
<ol>
<li>
<p>Set the <code>left</code> column number and the <code>right</code> column number, by sending the <strong>Column Address Set (CASET)</strong> Command</p>
</li>
<li>
<p>Set the <code>top</code> row number and the <code>bottom</code> row number, by sending the <strong>Row Address Set (RASET)</strong> Command</p>
<p>This step and the previous one are executed in a single function call...</p>
<pre><code class="language-c">pinetime_lvgl_mynewt_set_window(area-&gt;x1, area-&gt;y1, area-&gt;x2, area-&gt;y2);
</code></pre>
</li>
<li>
<p>Send the <strong>Memory Write (RAMWR)</strong> Command...</p>
<pre><code class="language-c">pinetime_lvgl_mynewt_write_command(RAMWR, NULL, 0);
</code></pre>
</li>
<li>
<p>Blast a sequence of data bytes containing the colours of the window pixels, <a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot#draw-a-line">in 16-bit RGB565 format</a>...</p>
<pre><code class="language-c">pinetime_lvgl_mynewt_write_data((const uint8_t *) color_p, len);    
</code></pre>
</li>
</ol>
<p>Here's how our function <code>pinetime_lvgl_mynewt_set_window</code> sends CASET and RASET Commands to set the window coordinates: <a href="https://gitlab.com/lupyuen/pinetime_lvgl_mynewt/blob/master/src/pinetime/display.c"><code>src/pinetime/display.c</code></a></p>
<pre><code class="language-c">/// Column Address Set (CASET) and Row Address Set (RASET) Commands
#define CASET 0x2A
#define RASET 0x2B

/// Set the ST7789 display window to the coordinates (left, top), (right, bottom)
int pinetime_lvgl_mynewt_set_window(uint8_t left, uint8_t top, uint8_t right, uint8_t bottom) {
    assert(left &lt; COL_COUNT &amp;&amp; right &lt; COL_COUNT &amp;&amp; top &lt; ROW_COUNT &amp;&amp; bottom &lt; ROW_COUNT);
    assert(left &lt;= right);
    assert(top &lt;= bottom);
    //  Set Address Window Columns (CASET)
    int rc = pinetime_lvgl_mynewt_write_command(CASET, NULL, 0); assert(rc == 0);
    uint8_t col_para[4] = { 0x00, left, 0x00, right };
    rc = pinetime_lvgl_mynewt_write_data(col_para, 4); assert(rc == 0);

    //  Set Address Window Rows (RASET)
    rc = pinetime_lvgl_mynewt_write_command(RASET, NULL, 0); assert(rc == 0);
    uint8_t row_para[4] = { 0x00, top, 0x00, bottom };
    rc = pinetime_lvgl_mynewt_write_data(row_para, 4); assert(rc == 0);
    return 0;
}
</code></pre>
<p>Here's how we transmit command and data bytes to ST7789 over the SPI port...</p>
<pre><code class="language-c">/// Transmit ST7789 command
int pinetime_lvgl_mynewt_write_command(uint8_t command, const uint8_t *params, uint16_t len) {
    hal_gpio_write(DISPLAY_DC, 0);
    int rc = transmit_spi(&amp;command, 1);
    assert(rc == 0);
    if (params != NULL &amp;&amp; len &gt; 0) {
        rc = pinetime_lvgl_mynewt_write_data(params, len);
        assert(rc == 0);
    }
    return 0;
}

/// Transmit ST7789 data
int pinetime_lvgl_mynewt_write_data(const uint8_t *data, uint16_t len) {
    hal_gpio_write(DISPLAY_DC, 1);
    transmit_spi(data, len);
    return 0;
}
</code></pre>
<p>We call the Mynewt function <code>hal_gpio_write</code> to toggle GPIO Pin 18 (DISPLAY_DC) to tell ST7789 whether we are sending a Command Byte or a sequence of Data Bytes.</p>
<table><thead><tr><th align="left">Mynewt Call</th><th align="left">Purpose</th></tr></thead><tbody>
<tr><td align="left"><code>hal_gpio_write(DISPLAY_DC, 0)</code></td><td align="left">To send a Command Byte</td></tr>
<tr><td align="left"><code>hal_gpio_write(DISPLAY_DC, 1)</code></td><td align="left">To send Data Bytes</td></tr>
</tbody></table>
<p>Yes it's unusual, cumbersome and limits SPI performance. It was probably done to force-fit a 4-Line Serial Interface into the 3-Line SPI Interface.</p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/mcuboot#blasting-graphics-to-st7789-display-controller-on-pinetime">More about PineTime's ST7789 Display Controller</a></p>
<p><img src="https://lupyuen.github.io/images/timesync-title.png" alt="PineTime Smart Watch with Rust Watch Face" /></p>
<h1 id="whats-next" class="section-header"><a href="#whats-next">9 What's Next</a></h1>
<p><em>We can build complicated Watch Faces in C... Right?</em></p>
<p>As our Watch Face code in C grows in complexity... It becomes harder to test, deploy, maintain and extend.</p>
<p>In the next article we'll look at a more sustainable way to build Watch Faces (like the one above)... With a <strong>Watch Face Framework in Rust</strong>!</p>
<p>Rust Watch Faces may also be catalogued at <strong><a href="https://crates.io/crates/barebones-watchface">crates.io</a></strong>... So that PineTime Owners may easily discover, extend and remix the Watch Faces.</p>
<p>Let's learn how in the next article...</p>
<p><a href="https://lupyuen.github.io/pinetime-rust-mynewt/articles/watchface">&quot;Create Your Own PineTime Watch Face in Rust... And Publish on crates.io&quot;</a></p>
<p><a href="https://lupyuen.github.io">Check out my PineTime articles</a></p>
<p><a href="https://lupyuen.github.io/rss.xml">RSS Feed</a></p>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here...</em></p>
<p><a href="https://github.com/lupyuen/pinetime-rust-mynewt/blob/master/rust/app/src/timesync.md"><code>github.com/lupyuen/pinetime-rust-mynewt/rust/app/src/timesync.md</code></a></p>
<p><img src="https://lupyuen.github.io/images/cloud-firmware.jpg" alt="Custom PineTime Firmware Built In The Cloud" /></p>

    
</body>
</html>